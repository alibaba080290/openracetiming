{"ast":null,"code":"var _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar util = require('./util');\nvar CREDENTIAL_FIELD_ID = [0x10, 0x0e];\nvar SSID_FIELD_ID = [0x10, 0x45];\nvar AUTH_TYPE_FIELD_ID = [0x10, 0x03];\nvar NETWORK_KEY_FIELD_ID = [0x10, 0x27];\nvar AUTH_TYPES = {\n  OPEN: [0x00, 0x00],\n  WPA2_PSK: [0x00, 0x20]\n};\nfunction _getLengthBytes(valueBytes) {\n  if (valueBytes.length > 255) {\n    return [Math.floor(valueBytes.length / 256), valueBytes.length % 256];\n  }\n  return [0x0, valueBytes.length];\n}\nfunction _arrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction _getNextTLV(bytes) {\n  var type = bytes.slice(0, 2);\n  var length = bytes.slice(2, 4);\n  var value = bytes.slice(4, 4 + (length[0] * 256 + length[1]));\n  return {\n    type: type,\n    length: length,\n    value: value\n  };\n}\nfunction decode(bytes) {\n  var result = {};\n  while (bytes.length > 0) {\n    var _getNextTLV2 = _getNextTLV(bytes),\n      type = _getNextTLV2.type,\n      value = _getNextTLV2.value;\n    bytes = bytes.slice(4 + value.length, bytes.length);\n    if (_arrayEqual(CREDENTIAL_FIELD_ID, type)) {\n      var credential = value;\n      while (credential.length > 0) {\n        var tlv = _getNextTLV(credential);\n        credential = credential.slice(4 + tlv.value.length, credential.length);\n        if (_arrayEqual(AUTH_TYPE_FIELD_ID, tlv.type)) {\n          result.authType = tlv.value;\n        } else if (_arrayEqual(SSID_FIELD_ID, tlv.type)) {\n          result.ssid = util.bytesToString(tlv.value);\n        } else if (_arrayEqual(NETWORK_KEY_FIELD_ID, tlv.type)) {\n          result.networkKey = util.bytesToString(tlv.value);\n        }\n      }\n    }\n  }\n  return result;\n}\nfunction encode(_ref) {\n  var ssid = _ref.ssid,\n    networkKey = _ref.networkKey,\n    _ref$authType = _ref.authType,\n    authType = _ref$authType === void 0 ? AUTH_TYPES.WPA2_PSK : _ref$authType;\n  if (typeof ssid !== 'string' || typeof networkKey !== 'string') {\n    throw new Error('');\n  }\n  ssid = util.stringToBytes(ssid);\n  networkKey = util.stringToBytes(networkKey);\n  var authTypeTLV = [].concat(AUTH_TYPE_FIELD_ID, [0x0, authType.length], _toConsumableArray(authType));\n  var ssidTLV = [].concat(SSID_FIELD_ID, [0x0, ssid.length], _toConsumableArray(ssid));\n  var networkKeyTLV = [].concat(NETWORK_KEY_FIELD_ID, [0x0, networkKey.length], _toConsumableArray(networkKey));\n  var credentialValue = [].concat(_toConsumableArray(authTypeTLV), _toConsumableArray(ssidTLV), _toConsumableArray(networkKeyTLV));\n  var credentialTLV = [].concat(CREDENTIAL_FIELD_ID, _toConsumableArray(_getLengthBytes(credentialValue)), _toConsumableArray(credentialValue));\n  return credentialTLV;\n}\nmodule.exports = {\n  encodePayload: encode,\n  decodePayload: decode,\n  authTypes: AUTH_TYPES\n};","map":{"version":3,"names":["util","require","CREDENTIAL_FIELD_ID","SSID_FIELD_ID","AUTH_TYPE_FIELD_ID","NETWORK_KEY_FIELD_ID","AUTH_TYPES","OPEN","WPA2_PSK","_getLengthBytes","valueBytes","length","Math","floor","_arrayEqual","arr1","arr2","i","_getNextTLV","bytes","type","slice","value","decode","result","_getNextTLV2","credential","tlv","authType","ssid","bytesToString","networkKey","encode","_ref","_ref$authType","Error","stringToBytes","authTypeTLV","concat","_toConsumableArray","ssidTLV","networkKeyTLV","credentialValue","credentialTLV","module","exports","encodePayload","decodePayload","authTypes"],"sources":["/home/admin/openracetiming/node_modules/react-native-nfc-manager/ndef-lib/ndef-wifi-simple.js"],"sourcesContent":["var util = require('./util');\n\nconst CREDENTIAL_FIELD_ID = [0x10, 0x0e];\nconst SSID_FIELD_ID = [0x10, 0x45];\nconst AUTH_TYPE_FIELD_ID = [0x10, 0x03];\nconst NETWORK_KEY_FIELD_ID = [0x10, 0x27];\n\nconst AUTH_TYPES = {\n  OPEN: [0x00, 0x00],\n  WPA2_PSK: [0x00, 0x20],\n};\n\nfunction _getLengthBytes(valueBytes) {\n  if (valueBytes.length > 255) {\n    return [Math.floor(valueBytes.length / 256), valueBytes.length % 256];\n  }\n  return [0x0, valueBytes.length];\n}\n\nfunction _arrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction _getNextTLV(bytes) {\n  const type = bytes.slice(0, 2);\n  const length = bytes.slice(2, 4);\n  const value = bytes.slice(4, 4 + (length[0] * 256 + length[1]));\n  return {\n    type,\n    length,\n    value,\n  };\n}\n\n// @returns an string of wifi credentials\nfunction decode(bytes) {\n  let result = {};\n\n  while (bytes.length > 0) {\n    let {type, value} = _getNextTLV(bytes);\n    bytes = bytes.slice(4 + value.length, bytes.length);\n\n    if (_arrayEqual(CREDENTIAL_FIELD_ID, type)) {\n      let credential = value;\n\n      while (credential.length > 0) {\n        let tlv = _getNextTLV(credential);\n        credential = credential.slice(4 + tlv.value.length, credential.length);\n\n        if (_arrayEqual(AUTH_TYPE_FIELD_ID, tlv.type)) {\n          result.authType = tlv.value;\n        } else if (_arrayEqual(SSID_FIELD_ID, tlv.type)) {\n          result.ssid = util.bytesToString(tlv.value);\n        } else if (_arrayEqual(NETWORK_KEY_FIELD_ID, tlv.type)) {\n          result.networkKey = util.bytesToString(tlv.value);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n// encode wifi object payload\n// @returns an array of bytes\nfunction encode({ssid, networkKey, authType = AUTH_TYPES.WPA2_PSK}) {\n  if (typeof ssid !== 'string' || typeof networkKey !== 'string') {\n    throw new Error('');\n  }\n\n  ssid = util.stringToBytes(ssid);\n  networkKey = util.stringToBytes(networkKey);\n\n  // build seperated TLV\n  const authTypeTLV = [\n    ...AUTH_TYPE_FIELD_ID,\n    0x0,\n    authType.length,\n    ...authType,\n  ];\n  const ssidTLV = [...SSID_FIELD_ID, 0x0, ssid.length, ...ssid];\n  const networkKeyTLV = [\n    ...NETWORK_KEY_FIELD_ID,\n    0x0,\n    networkKey.length,\n    ...networkKey,\n  ];\n\n  // build credential TLV\n  const credentialValue = [...authTypeTLV, ...ssidTLV, ...networkKeyTLV];\n  const credentialTLV = [\n    ...CREDENTIAL_FIELD_ID,\n    ..._getLengthBytes(credentialValue),\n    ...credentialValue,\n  ];\n\n  return credentialTLV;\n}\n\nmodule.exports = {\n  encodePayload: encode,\n  decodePayload: decode,\n  authTypes: AUTH_TYPES,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}