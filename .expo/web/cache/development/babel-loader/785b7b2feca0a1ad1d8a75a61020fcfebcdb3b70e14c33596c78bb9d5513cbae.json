{"ast":null,"code":"var util = require('./util');\nfunction createNdefRecord(tnf, type, id, payload) {\n  if (tnf === undefined || type === undefined || id === undefined || payload === undefined) {\n    throw new Error('missing required param');\n  }\n  if (type instanceof Array) {\n    type = util.bytesToString(type);\n  }\n  if (!(id instanceof Array)) {\n    id = util.stringToBytes(id);\n  }\n  if (!(payload instanceof Array)) {\n    payload = util.stringToBytes(payload);\n  }\n  return {\n    tnf: tnf,\n    type: type,\n    id: id,\n    payload: payload\n  };\n}\nfunction encodeNdefMessage(ndefRecords) {\n  var encodeTnf = function encodeTnf(_ref) {\n    var mb = _ref.mb,\n      me = _ref.me,\n      cf = _ref.cf,\n      sr = _ref.sr,\n      il = _ref.il,\n      tnf = _ref.tnf;\n    var value = tnf;\n    if (mb) {\n      value = value | 0x80;\n    }\n    if (me) {\n      value = value | 0x40;\n    }\n    if (cf) {\n      value = value | 0x20;\n    }\n    if (sr) {\n      value = value | 0x10;\n    }\n    if (il) {\n      value = value | 0x8;\n    }\n    return value;\n  };\n  var encoded = [],\n    tnf_byte,\n    record_type,\n    payload_length,\n    id_length,\n    i,\n    mb,\n    me,\n    cf = false,\n    sr,\n    il;\n  for (i = 0; i < ndefRecords.length; i++) {\n    mb = i === 0;\n    me = i === ndefRecords.length - 1;\n    sr = ndefRecords[i].payload.length < 0xff;\n    il = ndefRecords[i].id.length > 0;\n    tnf_byte = encodeTnf({\n      mb: mb,\n      me: me,\n      cf: cf,\n      sr: sr,\n      il: il,\n      tnf: ndefRecords[i].tnf\n    });\n    encoded.push(tnf_byte);\n    record_type = util.stringToBytes(ndefRecords[i].type);\n    encoded.push(record_type.length);\n    if (sr) {\n      payload_length = ndefRecords[i].payload.length;\n      encoded.push(payload_length);\n    } else {\n      payload_length = ndefRecords[i].payload.length;\n      encoded.push(payload_length >> 24);\n      encoded.push(payload_length >> 16);\n      encoded.push(payload_length >> 8);\n      encoded.push(payload_length & 0xff);\n    }\n    if (il) {\n      id_length = ndefRecords[i].id.length;\n      encoded.push(id_length);\n    }\n    encoded = encoded.concat(record_type);\n    if (il) {\n      encoded = encoded.concat(ndefRecords[i].id);\n    }\n    encoded = encoded.concat(ndefRecords[i].payload);\n  }\n  return encoded;\n}\nfunction decodeNdefMessage(ndefBytes) {\n  var decodeTnf = function decodeTnf(tnf_byte) {\n    return {\n      mb: (tnf_byte & 0x80) !== 0,\n      me: (tnf_byte & 0x40) !== 0,\n      cf: (tnf_byte & 0x20) !== 0,\n      sr: (tnf_byte & 0x10) !== 0,\n      il: (tnf_byte & 0x8) !== 0,\n      tnf: tnf_byte & 0x7\n    };\n  };\n  var bytes;\n  if (ndefBytes instanceof Array) {\n    bytes = ndefBytes.slice(0);\n  } else {\n    throw new Error('ndef.decodeMessage requires a Buffer or an Array of bytes');\n  }\n  bytes = bytes.slice(0);\n  var ndef_message = [],\n    tnf_byte,\n    header,\n    type_length = 0,\n    payload_length = 0,\n    id_length = 0,\n    record_type = [],\n    id = [],\n    payload = [];\n  while (bytes.length) {\n    tnf_byte = bytes.shift();\n    header = decodeTnf(tnf_byte);\n    type_length = bytes.shift();\n    if (header.sr) {\n      payload_length = bytes.shift();\n    } else {\n      payload_length = (0xff & bytes.shift()) << 24 | (0xff & bytes.shift()) << 16 | (0xff & bytes.shift()) << 8 | 0xff & bytes.shift();\n    }\n    id_length = header.il ? bytes.shift() : 0;\n    record_type = bytes.splice(0, type_length);\n    id = bytes.splice(0, id_length);\n    payload = bytes.splice(0, payload_length);\n    ndef_message.push(createNdefRecord(header.tnf, record_type, id, payload));\n    if (header.me) {\n      break;\n    }\n  }\n  return ndef_message;\n}\nfunction equalToRecordType(record, tnf, type) {\n  if (record.tnf === tnf) {\n    if (Array.isArray(record.type)) {\n      return util.bytesToString(record.type) === type;\n    } else {\n      return record.type === type;\n    }\n  }\n  return record.tnf === tnf && record.type === type;\n}\nmodule.exports = {\n  createNdefRecord: createNdefRecord,\n  encodeNdefMessage: encodeNdefMessage,\n  decodeNdefMessage: decodeNdefMessage,\n  equalToRecordType: equalToRecordType\n};","map":{"version":3,"names":["util","require","createNdefRecord","tnf","type","id","payload","undefined","Error","Array","bytesToString","stringToBytes","encodeNdefMessage","ndefRecords","encodeTnf","_ref","mb","me","cf","sr","il","value","encoded","tnf_byte","record_type","payload_length","id_length","i","length","push","concat","decodeNdefMessage","ndefBytes","decodeTnf","bytes","slice","ndef_message","header","type_length","shift","splice","equalToRecordType","record","isArray","module","exports"],"sources":["/home/admin/openracetiming/node_modules/react-native-nfc-manager/ndef-lib/ndef.js"],"sourcesContent":["const util = require('./util');\n\nfunction createNdefRecord(tnf, type, id, payload) {\n  if (\n    tnf === undefined ||\n    type === undefined ||\n    id === undefined ||\n    payload === undefined\n  ) {\n    throw new Error('missing required param');\n  }\n\n  // store type as String so it's easier to compare\n  if (type instanceof Array) {\n    type = util.bytesToString(type);\n  }\n\n  // in the future, id could be a String\n  if (!(id instanceof Array)) {\n    id = util.stringToBytes(id);\n  }\n\n  // Payload must be binary\n  if (!(payload instanceof Array)) {\n    payload = util.stringToBytes(payload);\n  }\n\n  return {\n    tnf: tnf,\n    type: type,\n    id: id,\n    payload: payload,\n  };\n}\n\nfunction encodeNdefMessage(ndefRecords) {\n  const encodeTnf = ({mb, me, cf, sr, il, tnf}) => {\n    let value = tnf;\n\n    if (mb) {\n      value = value | 0x80;\n    }\n\n    if (me) {\n      value = value | 0x40;\n    }\n\n    // note if cf: me, mb, li must be false and tnf must be 0x6\n    if (cf) {\n      value = value | 0x20;\n    }\n\n    if (sr) {\n      value = value | 0x10;\n    }\n\n    if (il) {\n      value = value | 0x8;\n    }\n\n    return value;\n  };\n\n  let encoded = [],\n    tnf_byte,\n    record_type,\n    payload_length,\n    id_length,\n    i,\n    mb,\n    me, // messageBegin, messageEnd\n    cf = false, // chunkFlag TODO implement\n    sr, // boolean shortRecord\n    il; // boolean idLengthFieldIsPresent\n\n  for (i = 0; i < ndefRecords.length; i++) {\n    mb = i === 0;\n    me = i === ndefRecords.length - 1;\n    sr = ndefRecords[i].payload.length < 0xff;\n    il = ndefRecords[i].id.length > 0;\n    tnf_byte = encodeTnf({mb, me, cf, sr, il, tnf: ndefRecords[i].tnf});\n    encoded.push(tnf_byte);\n\n    // type is stored as String, converting to bytes for storage\n    record_type = util.stringToBytes(ndefRecords[i].type);\n    encoded.push(record_type.length);\n\n    if (sr) {\n      payload_length = ndefRecords[i].payload.length;\n      encoded.push(payload_length);\n    } else {\n      payload_length = ndefRecords[i].payload.length;\n      // 4 bytes\n      encoded.push(payload_length >> 24);\n      encoded.push(payload_length >> 16);\n      encoded.push(payload_length >> 8);\n      encoded.push(payload_length & 0xff);\n    }\n\n    if (il) {\n      id_length = ndefRecords[i].id.length;\n      encoded.push(id_length);\n    }\n\n    encoded = encoded.concat(record_type);\n\n    if (il) {\n      encoded = encoded.concat(ndefRecords[i].id);\n    }\n\n    encoded = encoded.concat(ndefRecords[i].payload);\n  }\n\n  return encoded;\n}\n\nfunction decodeNdefMessage(ndefBytes) {\n  const decodeTnf = (tnf_byte) => ({\n    mb: (tnf_byte & 0x80) !== 0,\n    me: (tnf_byte & 0x40) !== 0,\n    cf: (tnf_byte & 0x20) !== 0,\n    sr: (tnf_byte & 0x10) !== 0,\n    il: (tnf_byte & 0x8) !== 0,\n    tnf: tnf_byte & 0x7,\n  });\n\n  // ndefBytes can be an array of bytes e.g. [0x03, 0x31, 0xd1] or a Buffer\n  let bytes;\n  if (ndefBytes instanceof Array) {\n    bytes = ndefBytes.slice(0);\n  } else {\n    throw new Error(\n      'ndef.decodeMessage requires a Buffer or an Array of bytes',\n    );\n  }\n\n  bytes = bytes.slice(0); // clone since parsing is destructive\n  let ndef_message = [],\n    tnf_byte,\n    header,\n    type_length = 0,\n    payload_length = 0,\n    id_length = 0,\n    record_type = [],\n    id = [],\n    payload = [];\n\n  while (bytes.length) {\n    tnf_byte = bytes.shift();\n    header = decodeTnf(tnf_byte);\n\n    type_length = bytes.shift();\n\n    if (header.sr) {\n      payload_length = bytes.shift();\n    } else {\n      // next 4 bytes are length\n      payload_length =\n        ((0xff & bytes.shift()) << 24) |\n        ((0xff & bytes.shift()) << 16) |\n        ((0xff & bytes.shift()) << 8) |\n        (0xff & bytes.shift());\n    }\n\n    id_length = header.il ? bytes.shift() : 0;\n\n    record_type = bytes.splice(0, type_length);\n    id = bytes.splice(0, id_length);\n    payload = bytes.splice(0, payload_length);\n\n    ndef_message.push(createNdefRecord(header.tnf, record_type, id, payload));\n\n    if (header.me) {\n      break;\n    } // last message\n  }\n\n  return ndef_message;\n}\n\nfunction equalToRecordType(record, tnf, type) {\n  if (record.tnf === tnf) {\n    if (Array.isArray(record.type)) {\n      return util.bytesToString(record.type) === type;\n    } else {\n      return record.type === type;\n    }\n  }\n  return record.tnf === tnf && record.type === type;\n}\n\nmodule.exports = {\n  createNdefRecord,\n  encodeNdefMessage,\n  decodeNdefMessage,\n  equalToRecordType,\n};\n"],"mappings":"AAAA,IAAMA,IAAI,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAE9B,SAASC,gBAAgBA,CAACC,GAAG,EAAEC,IAAI,EAAEC,EAAE,EAAEC,OAAO,EAAE;EAChD,IACEH,GAAG,KAAKI,SAAS,IACjBH,IAAI,KAAKG,SAAS,IAClBF,EAAE,KAAKE,SAAS,IAChBD,OAAO,KAAKC,SAAS,EACrB;IACA,MAAM,IAAIC,KAAK,CAAC,wBAAwB,CAAC;EAC3C;EAGA,IAAIJ,IAAI,YAAYK,KAAK,EAAE;IACzBL,IAAI,GAAGJ,IAAI,CAACU,aAAa,CAACN,IAAI,CAAC;EACjC;EAGA,IAAI,EAAEC,EAAE,YAAYI,KAAK,CAAC,EAAE;IAC1BJ,EAAE,GAAGL,IAAI,CAACW,aAAa,CAACN,EAAE,CAAC;EAC7B;EAGA,IAAI,EAAEC,OAAO,YAAYG,KAAK,CAAC,EAAE;IAC/BH,OAAO,GAAGN,IAAI,CAACW,aAAa,CAACL,OAAO,CAAC;EACvC;EAEA,OAAO;IACLH,GAAG,EAAEA,GAAG;IACRC,IAAI,EAAEA,IAAI;IACVC,EAAE,EAAEA,EAAE;IACNC,OAAO,EAAEA;EACX,CAAC;AACH;AAEA,SAASM,iBAAiBA,CAACC,WAAW,EAAE;EACtC,IAAMC,SAAS,GAAG,SAAZA,SAASA,CAAAC,IAAA,EAAkC;IAAA,IAA7BC,EAAE,GAAAD,IAAA,CAAFC,EAAE;MAAEC,EAAE,GAAAF,IAAA,CAAFE,EAAE;MAAEC,EAAE,GAAAH,IAAA,CAAFG,EAAE;MAAEC,EAAE,GAAAJ,IAAA,CAAFI,EAAE;MAAEC,EAAE,GAAAL,IAAA,CAAFK,EAAE;MAAEjB,GAAG,GAAAY,IAAA,CAAHZ,GAAG;IACzC,IAAIkB,KAAK,GAAGlB,GAAG;IAEf,IAAIa,EAAE,EAAE;MACNK,KAAK,GAAGA,KAAK,GAAG,IAAI;IACtB;IAEA,IAAIJ,EAAE,EAAE;MACNI,KAAK,GAAGA,KAAK,GAAG,IAAI;IACtB;IAGA,IAAIH,EAAE,EAAE;MACNG,KAAK,GAAGA,KAAK,GAAG,IAAI;IACtB;IAEA,IAAIF,EAAE,EAAE;MACNE,KAAK,GAAGA,KAAK,GAAG,IAAI;IACtB;IAEA,IAAID,EAAE,EAAE;MACNC,KAAK,GAAGA,KAAK,GAAG,GAAG;IACrB;IAEA,OAAOA,KAAK;EACd,CAAC;EAED,IAAIC,OAAO,GAAG,EAAE;IACdC,QAAQ;IACRC,WAAW;IACXC,cAAc;IACdC,SAAS;IACTC,CAAC;IACDX,EAAE;IACFC,EAAE;IACFC,EAAE,GAAG,KAAK;IACVC,EAAE;IACFC,EAAE;EAEJ,KAAKO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,WAAW,CAACe,MAAM,EAAED,CAAC,EAAE,EAAE;IACvCX,EAAE,GAAGW,CAAC,KAAK,CAAC;IACZV,EAAE,GAAGU,CAAC,KAAKd,WAAW,CAACe,MAAM,GAAG,CAAC;IACjCT,EAAE,GAAGN,WAAW,CAACc,CAAC,CAAC,CAACrB,OAAO,CAACsB,MAAM,GAAG,IAAI;IACzCR,EAAE,GAAGP,WAAW,CAACc,CAAC,CAAC,CAACtB,EAAE,CAACuB,MAAM,GAAG,CAAC;IACjCL,QAAQ,GAAGT,SAAS,CAAC;MAACE,EAAE,EAAFA,EAAE;MAAEC,EAAE,EAAFA,EAAE;MAAEC,EAAE,EAAFA,EAAE;MAAEC,EAAE,EAAFA,EAAE;MAAEC,EAAE,EAAFA,EAAE;MAAEjB,GAAG,EAAEU,WAAW,CAACc,CAAC,CAAC,CAACxB;IAAG,CAAC,CAAC;IACnEmB,OAAO,CAACO,IAAI,CAACN,QAAQ,CAAC;IAGtBC,WAAW,GAAGxB,IAAI,CAACW,aAAa,CAACE,WAAW,CAACc,CAAC,CAAC,CAACvB,IAAI,CAAC;IACrDkB,OAAO,CAACO,IAAI,CAACL,WAAW,CAACI,MAAM,CAAC;IAEhC,IAAIT,EAAE,EAAE;MACNM,cAAc,GAAGZ,WAAW,CAACc,CAAC,CAAC,CAACrB,OAAO,CAACsB,MAAM;MAC9CN,OAAO,CAACO,IAAI,CAACJ,cAAc,CAAC;IAC9B,CAAC,MAAM;MACLA,cAAc,GAAGZ,WAAW,CAACc,CAAC,CAAC,CAACrB,OAAO,CAACsB,MAAM;MAE9CN,OAAO,CAACO,IAAI,CAACJ,cAAc,IAAI,EAAE,CAAC;MAClCH,OAAO,CAACO,IAAI,CAACJ,cAAc,IAAI,EAAE,CAAC;MAClCH,OAAO,CAACO,IAAI,CAACJ,cAAc,IAAI,CAAC,CAAC;MACjCH,OAAO,CAACO,IAAI,CAACJ,cAAc,GAAG,IAAI,CAAC;IACrC;IAEA,IAAIL,EAAE,EAAE;MACNM,SAAS,GAAGb,WAAW,CAACc,CAAC,CAAC,CAACtB,EAAE,CAACuB,MAAM;MACpCN,OAAO,CAACO,IAAI,CAACH,SAAS,CAAC;IACzB;IAEAJ,OAAO,GAAGA,OAAO,CAACQ,MAAM,CAACN,WAAW,CAAC;IAErC,IAAIJ,EAAE,EAAE;MACNE,OAAO,GAAGA,OAAO,CAACQ,MAAM,CAACjB,WAAW,CAACc,CAAC,CAAC,CAACtB,EAAE,CAAC;IAC7C;IAEAiB,OAAO,GAAGA,OAAO,CAACQ,MAAM,CAACjB,WAAW,CAACc,CAAC,CAAC,CAACrB,OAAO,CAAC;EAClD;EAEA,OAAOgB,OAAO;AAChB;AAEA,SAASS,iBAAiBA,CAACC,SAAS,EAAE;EACpC,IAAMC,SAAS,GAAG,SAAZA,SAASA,CAAIV,QAAQ;IAAA,OAAM;MAC/BP,EAAE,EAAE,CAACO,QAAQ,GAAG,IAAI,MAAM,CAAC;MAC3BN,EAAE,EAAE,CAACM,QAAQ,GAAG,IAAI,MAAM,CAAC;MAC3BL,EAAE,EAAE,CAACK,QAAQ,GAAG,IAAI,MAAM,CAAC;MAC3BJ,EAAE,EAAE,CAACI,QAAQ,GAAG,IAAI,MAAM,CAAC;MAC3BH,EAAE,EAAE,CAACG,QAAQ,GAAG,GAAG,MAAM,CAAC;MAC1BpB,GAAG,EAAEoB,QAAQ,GAAG;IAClB,CAAC;EAAA,CAAC;EAGF,IAAIW,KAAK;EACT,IAAIF,SAAS,YAAYvB,KAAK,EAAE;IAC9ByB,KAAK,GAAGF,SAAS,CAACG,KAAK,CAAC,CAAC,CAAC;EAC5B,CAAC,MAAM;IACL,MAAM,IAAI3B,KAAK,CACb,2DACF,CAAC;EACH;EAEA0B,KAAK,GAAGA,KAAK,CAACC,KAAK,CAAC,CAAC,CAAC;EACtB,IAAIC,YAAY,GAAG,EAAE;IACnBb,QAAQ;IACRc,MAAM;IACNC,WAAW,GAAG,CAAC;IACfb,cAAc,GAAG,CAAC;IAClBC,SAAS,GAAG,CAAC;IACbF,WAAW,GAAG,EAAE;IAChBnB,EAAE,GAAG,EAAE;IACPC,OAAO,GAAG,EAAE;EAEd,OAAO4B,KAAK,CAACN,MAAM,EAAE;IACnBL,QAAQ,GAAGW,KAAK,CAACK,KAAK,CAAC,CAAC;IACxBF,MAAM,GAAGJ,SAAS,CAACV,QAAQ,CAAC;IAE5Be,WAAW,GAAGJ,KAAK,CAACK,KAAK,CAAC,CAAC;IAE3B,IAAIF,MAAM,CAAClB,EAAE,EAAE;MACbM,cAAc,GAAGS,KAAK,CAACK,KAAK,CAAC,CAAC;IAChC,CAAC,MAAM;MAELd,cAAc,GACX,CAAC,IAAI,GAAGS,KAAK,CAACK,KAAK,CAAC,CAAC,KAAK,EAAE,GAC5B,CAAC,IAAI,GAAGL,KAAK,CAACK,KAAK,CAAC,CAAC,KAAK,EAAG,GAC7B,CAAC,IAAI,GAAGL,KAAK,CAACK,KAAK,CAAC,CAAC,KAAK,CAAE,GAC5B,IAAI,GAAGL,KAAK,CAACK,KAAK,CAAC,CAAE;IAC1B;IAEAb,SAAS,GAAGW,MAAM,CAACjB,EAAE,GAAGc,KAAK,CAACK,KAAK,CAAC,CAAC,GAAG,CAAC;IAEzCf,WAAW,GAAGU,KAAK,CAACM,MAAM,CAAC,CAAC,EAAEF,WAAW,CAAC;IAC1CjC,EAAE,GAAG6B,KAAK,CAACM,MAAM,CAAC,CAAC,EAAEd,SAAS,CAAC;IAC/BpB,OAAO,GAAG4B,KAAK,CAACM,MAAM,CAAC,CAAC,EAAEf,cAAc,CAAC;IAEzCW,YAAY,CAACP,IAAI,CAAC3B,gBAAgB,CAACmC,MAAM,CAAClC,GAAG,EAAEqB,WAAW,EAAEnB,EAAE,EAAEC,OAAO,CAAC,CAAC;IAEzE,IAAI+B,MAAM,CAACpB,EAAE,EAAE;MACb;IACF;EACF;EAEA,OAAOmB,YAAY;AACrB;AAEA,SAASK,iBAAiBA,CAACC,MAAM,EAAEvC,GAAG,EAAEC,IAAI,EAAE;EAC5C,IAAIsC,MAAM,CAACvC,GAAG,KAAKA,GAAG,EAAE;IACtB,IAAIM,KAAK,CAACkC,OAAO,CAACD,MAAM,CAACtC,IAAI,CAAC,EAAE;MAC9B,OAAOJ,IAAI,CAACU,aAAa,CAACgC,MAAM,CAACtC,IAAI,CAAC,KAAKA,IAAI;IACjD,CAAC,MAAM;MACL,OAAOsC,MAAM,CAACtC,IAAI,KAAKA,IAAI;IAC7B;EACF;EACA,OAAOsC,MAAM,CAACvC,GAAG,KAAKA,GAAG,IAAIuC,MAAM,CAACtC,IAAI,KAAKA,IAAI;AACnD;AAEAwC,MAAM,CAACC,OAAO,GAAG;EACf3C,gBAAgB,EAAhBA,gBAAgB;EAChBU,iBAAiB,EAAjBA,iBAAiB;EACjBmB,iBAAiB,EAAjBA,iBAAiB;EACjBU,iBAAiB,EAAjBA;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}